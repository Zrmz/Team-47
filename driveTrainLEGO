from __future__ import print_function # use python 3 syntax but make it compatible with python 2
from __future__ import division       #                           ''
import time     # import the time library for the sleep function
import brickpi3 # import the BrickPi3 drivers
import grovepi

grovepi.set_bus("RPI_1")
BP = brickpi3.BrickPi3() # Create an instance of the BrickPi3 class. BP will be the BrickPi3 object.
BP.reset_all()

GYRO_PORT = BP.PORT_1
GUIDE_PORT = 4
FRONT_PORT = 3
BP.set_sensor_type(GYRO_PORT, BP.SENSOR_TYPE.EV3_GYRO_ABS_DPS)

optimalUlt= float(input("Enter the robot's optimal distance form the wall in cm: "))
speed = -1 * float(input("How fast should the robot move in DPS: "))

OUTER = BP.PORT_D
INNER = BP.PORT_A
# Identify which motor ports on the pi are used

time.sleep(2)

try:
    while True:
        optimalGyro = BP.get_sensor(GYRO_PORT)
        optimalGyro = optimalGyro[0] + 90

        while (grovepi.ultrasonicRead(FRONT_PORT) > 12):
            try:
                angle_delta = BP.get_sensor(GYRO_PORT)   # print the gyro sensor values
                angle_delta = angle_delta[0] + 90
                wall_delta = grovepi.ultrasonicRead(GUIDE_PORT)
                if (wall_delta > 60):
                    break
                
                correction = (wall_delta - optimalUlt) / optimalUlt * (optimalGyro - angle_delta) / optimalGyro * gain
            
                BP.set_motor_dps(OUTER, speed * (1 - correction))
                BP.set_motor_dps(INNER, speed)

            except brickpi3.SensorError as error:
                print(error)

        turn(90)

        time.sleep(0.02)  # delay for 0.02 seconds (20ms) to reduce the Raspberry Pi CPU load.

except KeyboardInterrupt: # except the program gets interrupted by Ctrl+C on the keyboard.
    BP.reset_all()        # Unconfigure the sensors, disable the motors, and restore the LED to the control of the BrickPi3 firmware.
